// Communitas - P2P Collaboration Platform
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod identity;
mod groups;
mod files;

use identity::{IdentityManager, UserIdentity};
use groups::{GroupManager, Group, GroupMessage, MessageContent};
use files::{FileManager, FileMetadata, UploadProgress};
use std::sync::Arc;
use tauri::{Manager, State, Emitter};
use tokio::sync::broadcast, RwLock;
use tracing::{info, warn, error, debug};

// Real P2P node integration with saorsa-core
use saorsa_core::{P2PNode, NodeConfig, PeerId, P2PEvent, NetworkAddress};
use std::net::SocketAddr;
use std::collections::HashMap;

#[derive(Debug)]
pub struct RealP2PNode {
    /// The actual saorsa-core P2P node
    node: Arc<P2PNode>,
    /// Our peer ID in the network
    peer_id: PeerId,
    /// Connected peers for tracking
    connected_peers: Arc<RwLock<HashMap<PeerId, SocketAddr>>>,
    /// Bootstrap connection status
    bootstrap_connected: bool,
}

impl RealP2PNode {
    /// Create a new real P2P node
    pub async fn new() -> anyhow::Result<Self> {
        info!("Creating real P2P node with saorsa-core...");
        
        // Create node configuration for Communitas
        let mut node_config = NodeConfig::new()?;
        
        // Configure for development/testing - bind to random available port
        node_config.listen_addr = "0.0.0.0:0".parse()?;
        
        // Enable bootstrap discovery
        node_config.bootstrap_peers_str = vec![
            "quic.saorsalabs.com:8888".to_string(),  // Production bootstrap
        ];
        
        // Enable MCP server for AI integration
        node_config.enable_mcp_server = true;
        
        // Create the P2P node
        let node = P2PNode::new(node_config).await
            .map_err(|e| anyhow::anyhow!("Failed to create P2P node: {}", e))?;
            
        let peer_id = node.peer_id().clone();
        
        info!("Real P2P node created successfully with peer ID: {}", peer_id);
        
        Ok(Self {
            node: Arc::new(node),
            peer_id,
            connected_peers: Arc::new(RwLock::new(HashMap::new())),
            bootstrap_connected: false,
        })
    }

    /// Initialize P2P networking and connect to bootstrap nodes
    pub async fn initialize(&mut self) -> anyhow::Result<()> {
        info!("Initializing real P2P networking...");
        
        // Start the P2P node
        self.node.run_in_background().await
            .map_err(|e| anyhow::anyhow!("Failed to start P2P node: {}", e))?;
            
        // Start background event processing
        self.start_event_processor().await;
        
        // Connect to bootstrap nodes
        let bootstrap_result = self.connect_to_bootstrap().await;
        match bootstrap_result {
            Ok(connected_peers) => {
                info!("Successfully connected to {} bootstrap peers", connected_peers);
                self.bootstrap_connected = true;
            }
            Err(e) => {
                warn!("Bootstrap connection failed: {}, continuing in standalone mode", e);
                // Continue without bootstrap - can still accept local connections
                self.bootstrap_connected = false;
            }
        }
        
        info!("Real P2P node initialization completed");
        Ok(())
    }

    /// Connect to bootstrap nodes
    async fn connect_to_bootstrap(&self) -> anyhow::Result<usize> {
        info!("Connecting to P2P bootstrap nodes...");
        
        let bootstrap_addrs = vec![
            "quic.saorsalabs.com:8888".to_string(),
        ];
        
        let mut connected_count = 0;
        for addr_str in bootstrap_addrs {
            let addr: SocketAddr = addr_str.parse()?;
            let network_addr = NetworkAddress::new(addr);
            match self.node.connect_to_peer(network_addr).await {
                Ok(peer_id) => {
                    info!("Connected to bootstrap peer: {} at {}", peer_id, addr);
                    self.connected_peers.write().await.insert(peer_id, addr);
                    connected_count += 1;
                }
                Err(e) => {
                    warn!("Failed to connect to bootstrap {}: {}", addr, e);
                }
            }
        }
        
        if connected_count == 0 {
            return Err(anyhow::anyhow!("Failed to connect to any bootstrap nodes"));
        }
        
        Ok(connected_count)
    }

    /// Start background event processing
    async fn start_event_processor(&self) {
        let connected_peers = Arc::clone(&self.connected_peers);
        let peer_id = self.peer_id.clone();
        
        // Spawn background task to process P2P events
        tokio::spawn(async move {
            info!("Starting P2P event processor for peer {}", peer_id);
            
            // This will be implemented to handle P2P events
            // For now, just log that it's running
            loop {
                tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
                let peer_count = connected_peers.read().await.len();
                debug!("P2P node {} has {} connected peers", peer_id, peer_count);
            }
        });
    }

    /// Store data in the DHT
    pub async fn dht_put(&self, key: Vec<u8>, data: Vec<u8>) -> anyhow::Result<()> {
        info!("Storing {} bytes in DHT with key length {}", data.len(), key.len());
        
        self.node.dht_put(key.into(), data.into()).await
            .map_err(|e| anyhow::anyhow!("DHT PUT failed: {}", e))?;
            
        debug!("DHT PUT operation completed successfully");
        Ok(())
    }

    /// Retrieve data from the DHT  
    pub async fn dht_get(&self, key: Vec<u8>) -> anyhow::Result<Option<Vec<u8>>> {
        debug!("Retrieving data from DHT with key length {}", key.len());
        
        match self.node.dht_get(&key.into()).await {
            Ok(Some(record)) => {
                let data = record.value.to_vec();
                info!("DHT GET retrieved {} bytes", data.len());
                Ok(Some(data))
            }
            Ok(None) => {
                debug!("DHT GET found no data for key");
                Ok(None)
            }
            Err(e) => {
                error!("DHT GET failed: {}", e);
                Err(anyhow::anyhow!("DHT GET failed: {}", e))
            }
        }
    }

    /// Send a message to a specific peer
    pub async fn send_message(&self, peer_id: &PeerId, protocol: &str, data: Vec<u8>) -> anyhow::Result<()> {
        info!("Sending {} byte message to peer {} on protocol {}", data.len(), peer_id, protocol);
        
        self.node.send_message(peer_id, protocol, data).await
            .map_err(|e| anyhow::anyhow!("Failed to send message: {}", e))?;
            
        debug!("Message sent successfully to peer {}", peer_id);
        Ok(())
    }

    /// Get our peer ID
    pub fn peer_id(&self) -> &PeerId {
        &self.peer_id
    }

    /// Get list of connected peers
    pub async fn connected_peers(&self) -> Vec<PeerId> {
        self.connected_peers.read().await.keys().cloned().collect()
    }

    /// Check if connected to bootstrap
    pub fn is_bootstrap_connected(&self) -> bool {
        self.bootstrap_connected
    }

    /// Get network stats
    pub async fn network_stats(&self) -> HashMap<String, serde_json::Value> {
        let mut stats = HashMap::new();
        
        stats.insert("peer_id".to_string(), 
            serde_json::Value::String(self.peer_id.clone()));
        stats.insert("connected_peers".to_string(), 
            serde_json::Value::Number(self.connected_peers.read().await.len().into()));
        stats.insert("bootstrap_connected".to_string(), 
            serde_json::Value::Bool(self.bootstrap_connected));
            
        // Try to get additional stats from the node
        if let Some(local_addr) = self.node.local_addr() {
            stats.insert("local_addr".to_string(), 
                serde_json::Value::String(local_addr));
        }
        
        stats
    }
}

// Application state with real P2P node
struct AppState {
    p2p_node: Arc<RwLock<Option<RealP2PNode>>>,
    identity_manager: Arc<IdentityManager>,
    group_manager: Arc<GroupManager>,
    file_manager: Arc<FileManager>,
}

impl AppState {
    fn new() -> Self {
        Self {
            p2p_node: Arc::new(RwLock::new(None)),
            identity_manager: Arc::new(IdentityManager::new()),
            group_manager: Arc::new(GroupManager::new()),
            file_manager: Arc::new(FileManager::new()),
        }
    }

    async fn initialize_p2p_node(&self) -> anyhow::Result<String> {
        info!("Initializing real P2P node for Communitas...");
        
        let mut node = RealP2PNode::new().await?;
        node.initialize().await?;
        
        let node_id = node.peer_id().clone();
        *self.p2p_node.write().await = Some(node);
        
        info!("Real P2P node initialized successfully with ID: {}", node_id);
        Ok(node_id)
    }
}
// P2P Node Commands - Updated for real P2P integration
#[tauri::command]
async fn initialize_p2p_node(state: State<'_, AppState>) -> Result<String, String> {
    state.initialize_p2p_node().await
        .map_err(|e| {
            error!("P2P node initialization failed: {}", e);
            format!("P2P initialization failed: {}", e)
        })
}

#[tauri::command]
async fn get_node_status(state: State<'_, AppState>) -> Result<serde_json::Value, String> {
    let node_guard = state.p2p_node.read().await;
    
    match node_guard.as_ref() {
        Some(node) => {
            let stats = node.network_stats().await;
            Ok(serde_json::json!({
                "initialized": true,
                "peer_id": node.peer_id(),
                "connected_peers": node.connected_peers().await.len(),
                "bootstrap_connected": node.is_bootstrap_connected(),
                "dht_enabled": true,
                "status": "real P2P networking active",
                "network_stats": stats
            }))
        },
        None => Ok(serde_json::json!({
            "initialized": false,
            "error": "P2P node not initialized"
        }))
    }
}

// DHT Commands - Real DHT implementation
#[tauri::command]
async fn dht_put(
    key: String,
    value: serde_json::Value,
    state: State<'_, AppState>
) -> Result<(), String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let key_bytes = key.into_bytes();
    let value_bytes = serde_json::to_vec(&value)
        .map_err(|e| format!("Failed to serialize value: {}", e))?;

    node.dht_put(key_bytes, value_bytes).await
        .map_err(|e| format!("DHT PUT failed: {}", e))?;

    info!("DHT PUT completed for key: {}", key);
    Ok(())
}

#[tauri::command]
async fn dht_get(
    key: String,
    state: State<'_, AppState>
) -> Result<Option<serde_json::Value>, String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let key_bytes = key.into_bytes();
    
    match node.dht_get(key_bytes).await {
        Ok(Some(data)) => {
            let value: serde_json::Value = serde_json::from_slice(&data)
                .map_err(|e| format!("Failed to deserialize value: {}", e))?;
            info!("DHT GET retrieved data for key: {}", key);
            Ok(Some(value))
        }
        Ok(None) => {
            info!("DHT GET found no data for key: {}", key);
            Ok(None)
        }
        Err(e) => Err(format!("DHT GET failed: {}", e))
    }
}

// P2P Messaging Commands - Real implementation
#[tauri::command]
async fn send_p2p_message(
    peer_id: String,
    protocol: String,
    data: serde_json::Value,
    state: State<'_, AppState>
) -> Result<(), String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let data_bytes = serde_json::to_vec(&data)
        .map_err(|e| format!("Failed to serialize data: {}", e))?;

    node.send_message(&peer_id, &protocol, data_bytes).await
        .map_err(|e| format!("Failed to send P2P message: {}", e))?;

    info!("P2P message sent to {} on protocol {}", peer_id, protocol);
    Ok(())
}

#[tauri::command]
async fn get_connected_peers(state: State<'_, AppState>) -> Result<Vec<String>, String> {
    let node_guard = state.p2p_node.read().await;
    
    match node_guard.as_ref() {
        Some(node) => {
            let peers = node.connected_peers().await;
            Ok(peers)
        },
        None => Err("P2P node not initialized".to_string())
    }
}
