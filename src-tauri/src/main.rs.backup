// Communitas - P2P Collaboration Platform
#![allow(dead_code)]
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod identity;
mod groups;
mod files;

use identity::{IdentityManager};
use groups::{GroupManager};
use files::{FileManager};
use std::sync::Arc;
use tauri::{Manager, State, Emitter};
use tokio::sync::{RwLock};
use anyhow;
use tracing::{info, warn, error, debug};

// Real P2P node integration with saorsa-core
use saorsa_core::{P2PNode, NodeConfig, PeerId};
use saorsa_core::config::Config;
use std::net::SocketAddr;
use std::collections::HashMap;

#[allow(dead_code, missing_debug_implementations)]
pub struct RealP2PNode {
    /// The actual saorsa-core P2P node
    node: Arc<P2PNode>,
    /// Our peer ID in the network
    peer_id: PeerId,
    /// Connected peers for tracking
    connected_peers: Arc<RwLock<HashMap<PeerId, SocketAddr>>>,
    /// Bootstrap connection status
    bootstrap_connected: bool,
}

impl RealP2PNode {
    /// Create a new real P2P node
    pub async fn new() -> anyhow::Result<Self> {
        info!("Creating real P2P node with saorsa-core...");
        
        // Create node configuration for Communitas
        // First create a proper Config with bootstrap nodes
        let mut config = Config::default();
        config.network.bootstrap_nodes = vec![
            "159.89.81.21:8888".to_string(),  // Production bootstrap
        ];
        
        // Create node configuration from the Config
        let mut node_config = NodeConfig::from_config(&config)?;
        
        // Configure for development/testing - bind to random available port
        node_config.listen_addr = "0.0.0.0:0".parse()?;
        
        // Enable bootstrap discovery
        node_config.bootstrap_peers_str = vec![
            "159.89.81.21:8888".to_string(),  // Production bootstrap
        ];
        
        // Enable MCP server for AI integration
        node_config.enable_mcp_server = true;
        
        // Create the P2P node
        let node = P2PNode::new(node_config).await
            .map_err(|e| anyhow::anyhow!("Failed to create P2P node: {}", e))?;
            
        let peer_id = node.peer_id().clone();
        
        info!("Real P2P node created successfully with peer ID: {}", peer_id);
        
        Ok(Self {
            node: Arc::new(node),
            peer_id,
            connected_peers: Arc::new(RwLock::new(HashMap::new())),
            bootstrap_connected: false,
        })
    }

    /// Initialize P2P networking and connect to bootstrap nodes
    pub async fn initialize(&mut self) -> anyhow::Result<()> {
        info!("Initializing real P2P networking...");
        
        // Start the P2P node
        self.node.run().await
            .map_err(|e| anyhow::anyhow!("Failed to start P2P node: {}", e))?;
            
        // Start background event processing
        self.start_event_processor().await;
        
        // Connect to bootstrap nodes
        let bootstrap_result = self.connect_to_bootstrap().await;
        match bootstrap_result {
            Ok(connected_peers) => {
                info!("Successfully connected to {} bootstrap peers", connected_peers);
                self.bootstrap_connected = true;
            }
            Err(e) => {
                warn!("Bootstrap connection failed: {}, continuing in standalone mode", e);
                // Continue without bootstrap - can still accept local connections
                self.bootstrap_connected = false;
            }
        }
        
        info!("Real P2P node initialization completed");
        Ok(())
    }

    /// Connect to bootstrap nodes
    async fn connect_to_bootstrap(&self) -> anyhow::Result<usize> {
        info!("Connecting to P2P bootstrap nodes...");
        
        let bootstrap_addrs = vec![
            "159.89.81.21:8888".to_string(),
        ];
        
        let mut connected_count = 0;
        for addr_str in bootstrap_addrs {
            let addr: SocketAddr = addr_str.parse()?;
            match self.node.connect_peer(&addr_str).await {
                Ok(peer_id) => {
                    info!("Connected to bootstrap peer: {} at {}", peer_id, addr);
                    self.connected_peers.write().await.insert(peer_id, addr);
                    connected_count += 1;
                }
                Err(e) => {
                    warn!("Failed to connect to bootstrap {}: {}", addr, e);
                }
            }
        }
        
        if connected_count == 0 {
            return Err(anyhow::anyhow!("Failed to connect to any bootstrap nodes"));
        }
        
        Ok(connected_count)
    }

    /// Start background event processing
    async fn start_event_processor(&self) {
        let connected_peers = Arc::clone(&self.connected_peers);
        let peer_id = self.peer_id.clone();
        
        // Spawn background task to process P2P events
        tokio::spawn(async move {
            info!("Starting P2P event processor for peer {}", peer_id);
            
            // This will be implemented to handle P2P events
            // For now, just log that it's running
            loop {
                tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
                let peer_count = connected_peers.read().await.len();
                debug!("P2P node {} has {} connected peers", peer_id, peer_count);
            }
        });
    }

    /// Store data in the DHT
    pub async fn dht_put(&self, key: Vec<u8>, data: Vec<u8>) -> anyhow::Result<()> {
        info!("Storing {} bytes in DHT with key length {}", data.len(), key.len());
        
        self.node.dht_put(saorsa_core::Key::new(&key), data.into()).await
            .map_err(|e| anyhow::anyhow!("DHT PUT failed: {}", e))?;
            
        debug!("DHT PUT operation completed successfully");
        Ok(())
    }

    /// Retrieve data from the DHT  
    pub async fn dht_get(&self, key: Vec<u8>) -> anyhow::Result<Option<Vec<u8>>> {
        debug!("Retrieving data from DHT with key length {}", key.len());
        
        match self.node.dht_get(saorsa_core::Key::new(&key)).await {
            Ok(Some(data)) => {
                info!("DHT GET retrieved {} bytes", data.len());
                Ok(Some(data))
            }
            Ok(None) => {
                debug!("DHT GET found no data for key");
                Ok(None)
            }
            Err(e) => {
                error!("DHT GET failed: {}", e);
                Err(anyhow::anyhow!("DHT GET failed: {}", e))
            }
        }
    }

    /// Send a message to a specific peer
    pub async fn send_message(&self, peer_id: &PeerId, protocol: &str, data: Vec<u8>) -> anyhow::Result<()> {
        info!("Sending {} byte message to peer {} on protocol {}", data.len(), peer_id, protocol);
        
        self.node.send_message(peer_id, protocol, data).await
            .map_err(|e| anyhow::anyhow!("Failed to send message: {}", e))?;
            
        debug!("Message sent successfully to peer {}", peer_id);
        Ok(())
    }

    /// Get our peer ID
    pub fn peer_id(&self) -> &PeerId {
        &self.peer_id
    }

    /// Get list of connected peers
    pub async fn connected_peers(&self) -> Vec<PeerId> {
        self.connected_peers.read().await.keys().cloned().collect()
    }

    /// Check if connected to bootstrap
    pub fn is_bootstrap_connected(&self) -> bool {
        self.bootstrap_connected
    }

    /// Get network stats
    pub async fn network_stats(&self) -> HashMap<String, serde_json::Value> {
        let mut stats = HashMap::new();
        
        stats.insert("peer_id".to_string(), 
            serde_json::Value::String(self.peer_id.clone()));
        stats.insert("connected_peers".to_string(), 
            serde_json::Value::Number(self.connected_peers.read().await.len().into()));
        stats.insert("bootstrap_connected".to_string(), 
            serde_json::Value::Bool(self.bootstrap_connected));
            
        // Try to get additional stats from the node
        if let Some(local_addr) = self.node.local_addr() {
            stats.insert("local_addr".to_string(), 
                serde_json::Value::String(local_addr));
        }
        
        stats
    }
}

// Application state with real P2P node
struct AppState {
    p2p_node: Arc<RwLock<Option<RealP2PNode>>>,
    identity_manager: Arc<IdentityManager>,
    group_manager: Arc<GroupManager>,
    file_manager: Arc<FileManager>,
}

impl AppState {
    fn new() -> Self {
        Self {
            p2p_node: Arc::new(RwLock::new(None)),
            identity_manager: Arc::new(IdentityManager::new()),
            group_manager: Arc::new(GroupManager::new()),
            file_manager: Arc::new(FileManager::new()),
        }
    }

    async fn initialize_p2p_node(&self) -> anyhow::Result<String> {
        info!("Initializing real P2P node for Communitas...");
        
        let mut node = RealP2PNode::new().await?;
        node.initialize().await?;
        
        let node_id = node.peer_id().clone();
        *self.p2p_node.write().await = Some(node);
        
        info!("Real P2P node initialized successfully with ID: {}", node_id);
        Ok(node_id)
    }
}

// P2P Node Commands - Updated for real P2P integration
#[tauri::command]
async fn initialize_p2p_node(state: State<'_, AppState>) -> Result<String, String> {
    state.initialize_p2p_node().await
        .map_err(|e| {
            error!("P2P node initialization failed: {}", e);
            format!("P2P initialization failed: {}", e)
        })
}

#[tauri::command]
async fn get_node_status(state: State<'_, AppState>) -> Result<serde_json::Value, String> {
    let node_guard = state.p2p_node.read().await;
    
    match node_guard.as_ref() {
        Some(node) => {
            let stats = node.network_stats().await;
            Ok(serde_json::json!({
                "initialized": true,
                "peer_id": node.peer_id(),
                "connected_peers": node.connected_peers().await.len(),
                "bootstrap_connected": node.is_bootstrap_connected(),
                "dht_enabled": true,
                "status": "real P2P networking active",
                "network_stats": stats
            }))
        },
        None => Ok(serde_json::json!({
            "initialized": false,
            "error": "P2P node not initialized"
        }))
    }
}

// DHT Commands - Real DHT implementation
#[tauri::command]
async fn dht_put(
    key: String,
    value: serde_json::Value,
    state: State<'_, AppState>
) -> Result<(), String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let key_bytes = key.clone().into_bytes();
    let value_bytes = serde_json::to_vec(&value)
        .map_err(|e| format!("Failed to serialize value: {}", e))?;

    node.dht_put(key_bytes, value_bytes).await
        .map_err(|e| format!("DHT PUT failed: {}", e))?;

    info!("DHT PUT completed for key: {}", key);
    Ok(())
}

#[tauri::command]
async fn dht_get(
    key: String,
    state: State<'_, AppState>
) -> Result<Option<serde_json::Value>, String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let key_bytes = key.clone().into_bytes();
    
    match node.dht_get(key_bytes).await {
        Ok(Some(data)) => {
            let value: serde_json::Value = serde_json::from_slice(&data)
                .map_err(|e| format!("Failed to deserialize value: {}", e))?;
            info!("DHT GET retrieved data for key: {}", key);
            Ok(Some(value))
        }
        Ok(None) => {
            info!("DHT GET found no data for key: {}", key);
            Ok(None)
        }
        Err(e) => Err(format!("DHT GET failed: {}", e))
    }
}

// P2P Messaging Commands - Real implementation
#[tauri::command]
async fn send_p2p_message(
    peer_id: String,
    protocol: String,
    data: serde_json::Value,
    state: State<'_, AppState>
) -> Result<(), String> {
    let node_guard = state.p2p_node.read().await;
    let node = node_guard.as_ref()
        .ok_or("P2P node not initialized")?;

    let data_bytes = serde_json::to_vec(&data)
        .map_err(|e| format!("Failed to serialize data: {}", e))?;

    node.send_message(&peer_id, &protocol, data_bytes).await
        .map_err(|e| format!("Failed to send P2P message: {}", e))?;

    info!("P2P message sent to {} on protocol {}", peer_id, protocol);
    Ok(())
}

#[tauri::command]
async fn get_connected_peers(state: State<'_, AppState>) -> Result<Vec<String>, String> {
    let node_guard = state.p2p_node.read().await;
    
    match node_guard.as_ref() {
        Some(node) => {
            let peers = node.connected_peers().await;
            Ok(peers)
        },
        None => Err("P2P node not initialized".to_string())
    }
}

// Simplified placeholder commands for other modules
#[tauri::command]
async fn create_identity(
    _name: String,
    _avatar: Option<String>,
    _state: State<'_, AppState>
) -> Result<String, String> {
    Ok("identity_id_placeholder".to_string())
}

#[tauri::command]
async fn get_identity(_state: State<'_, AppState>) -> Result<Option<serde_json::Value>, String> {
    Ok(Some(serde_json::json!({"id": "placeholder", "name": "Test User"})))
}

#[tauri::command]
async fn update_profile(
    _name: String,
    _avatar: Option<String>,
    _state: State<'_, AppState>
) -> Result<(), String> {
    Ok(())
}

#[tauri::command]
async fn lookup_identity(
    _peer_id: String,
    _state: State<'_, AppState>
) -> Result<Option<serde_json::Value>, String> {
    Ok(None)
}

#[tauri::command]
async fn create_group(
    _name: String,
    _description: String,
    _state: State<'_, AppState>
) -> Result<String, String> {
    Ok("group_id_placeholder".to_string())
}

#[tauri::command]
async fn add_group_member(
    _group_id: String,
    _peer_id: String,
    _state: State<'_, AppState>
) -> Result<(), String> {
    Ok(())
}

#[tauri::command]
async fn send_group_message(
    _group_id: String,
    _content: String,
    _state: State<'_, AppState>
) -> Result<String, String> {
    Ok("message_id_placeholder".to_string())
}

#[tauri::command]
async fn get_group_messages(
    _group_id: String,
    _limit: Option<u32>,
    _state: State<'_, AppState>
) -> Result<Vec<serde_json::Value>, String> {
    Ok(vec![])
}

#[tauri::command]
async fn get_user_groups(_state: State<'_, AppState>) -> Result<Vec<serde_json::Value>, String> {
    Ok(vec![])
}

#[tauri::command]
async fn add_reaction(
    _message_id: String,
    _reaction: String,
    _state: State<'_, AppState>
) -> Result<(), String> {
    Ok(())
}

#[tauri::command]
async fn upload_file(
    _file_path: String,
    _target_group: Option<String>,
    _state: State<'_, AppState>
) -> Result<String, String> {
    Ok("file_id_placeholder".to_string())
}

#[tauri::command]
async fn download_file(
    _file_id: String,
    _download_path: String,
    _state: State<'_, AppState>
) -> Result<(), String> {
    Ok(())
}

#[tauri::command]
async fn get_file_info(
    _file_id: String,
    _state: State<'_, AppState>
) -> Result<Option<serde_json::Value>, String> {
    Ok(None)
}

#[tauri::command]
async fn list_user_files(_state: State<'_, AppState>) -> Result<Vec<serde_json::Value>, String> {
    Ok(vec![])
}

#[tauri::command]
async fn list_group_files(
    _group_id: String,
    _state: State<'_, AppState>
) -> Result<Vec<serde_json::Value>, String> {
    Ok(vec![])
}

#[tauri::command]
async fn delete_file(
    _file_id: String,
    _state: State<'_, AppState>
) -> Result<(), String> {
    Ok(())
}

#[tauri::command]
async fn get_user_storage(_state: State<'_, AppState>) -> Result<serde_json::Value, String> {
    Ok(serde_json::json!({"used": 0, "total": 1000000000}))
}

#[tauri::command]
async fn get_upload_progress(
    _file_id: String,
    _state: State<'_, AppState>
) -> Result<Option<serde_json::Value>, String> {
    Ok(None)
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tracing_subscriber::fmt::init();
    
    // Initialize rustls crypto provider
    let _ = rustls::crypto::aws_lc_rs::default_provider().install_default();    
    let app_state = AppState::new();

    tauri::Builder::default()
        .setup(|app| {
            let app_handle = app.handle().clone();
            
            // Initialize P2P node in background
            tauri::async_runtime::spawn(async move {
                // Small delay to let the app start
                tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;
                
                match app_handle.state::<AppState>().initialize_p2p_node().await {
                    Ok(peer_id) => {
                        info!("P2P node auto-initialized with peer ID: {}", peer_id);
                        
                        // Emit success event to frontend
                        if let Err(e) = app_handle.emit("p2p-initialized", serde_json::json!({
                            "peer_id": peer_id,
                            "status": "connected"
                        })) {
                            error!("Failed to emit p2p-initialized event: {}", e);
                        }
                    }
                    Err(e) => {
                        error!("Failed to auto-initialize P2P node: {}", e);
                        
                        // Emit error event to frontend
                        if let Err(e) = app_handle.emit("p2p-error", serde_json::json!({
                            "error": e.to_string()
                        })) {
                            error!("Failed to emit p2p-error event: {}", e);
                        }
                    }
                }
            });

            #[cfg(debug_assertions)]
            {
                let window = app.get_webview_window("main").unwrap();
                window.open_devtools();
            }
            
            Ok(())
        })
        .manage(app_state)
        .invoke_handler(tauri::generate_handler![
            // P2P node commands
            initialize_p2p_node,
            get_node_status,
            dht_put,
            dht_get,
            send_p2p_message,
            get_connected_peers,
            // Identity commands (simplified)
            create_identity,
            get_identity,
            update_profile,
            lookup_identity,
            // Group commands (simplified)
            create_group,
            add_group_member,
            send_group_message,
            get_group_messages,
            get_user_groups,
            add_reaction,
            // File commands (simplified)
            upload_file,
            download_file,
            get_file_info,
            list_user_files,
            list_group_files,
            delete_file,
            get_user_storage,
            get_upload_progress,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

fn main() {
    run();
}
