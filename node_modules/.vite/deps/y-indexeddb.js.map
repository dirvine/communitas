{
  "version": 3,
  "sources": ["../../lib0/indexeddb.js", "../../y-indexeddb/src/y-indexeddb.js"],
  "sourcesContent": ["/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module indexeddb\n */\n\nimport * as promise from './promise.js'\nimport * as error from './error.js'\n\n/* c8 ignore start */\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\nexport const rtop = request => promise.create((resolve, reject) => {\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\nexport const openDB = (name, initDB) => promise.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(error.create(event.target.error))\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    db.onversionchange = () => { db.close() }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\nexport const deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\nexport const createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {\"readwrite\"|\"readonly\"} [access]\n * @return {Array<IDBObjectStore>}\n */\nexport const transact = (db, stores, access = 'readwrite') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\nexport const count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\nexport const get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\nexport const del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\nexport const put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\nexport const add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\nexport const addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<any>>}\n */\nexport const getAll = (store, range, limit) =>\n  rtop(store.getAll(range, limit))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<any>>}\n */\nexport const getAllKeys = (store, range, limit) =>\n  rtop(store.getAllKeys(range, limit))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n * @return {Promise<any>}\n */\nexport const queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange?} [range]\n * @return {Promise<any>}\n */\nexport const getLastKey = (store, range = null) => queryFirst(store, range, 'prev')\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange?} [range]\n * @return {Promise<any>}\n */\nexport const getFirstKey = (store, range = null) => queryFirst(store, range, 'next')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @param {number} [limit]\n * @return {Promise<Array<KeyValuePair>>}\n */\nexport const getAllKeysValues = (store, range, limit) =>\n  // @ts-ignore\n  promise.all([getAllKeys(store, range, limit), getAll(store, range, limit)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean|Promise<void|boolean>} f\n * @return {Promise<void>}\n */\nconst iterateOnRequest = (request, f) => promise.create((resolve, reject) => {\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = async event => {\n    const cursor = event.target.result\n    if (cursor === null || (await f(cursor)) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean|Promise<void|boolean>} f Callback that receives (value, key)\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\nexport const iterate = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean|Promise<void|boolean>} f callback that receives the key\n * @param {'next'|'prev'|'nextunique'|'prevunique'} direction\n */\nexport const iterateKeys = (store, keyrange, f, direction = 'next') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\nexport const getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\nexport const createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\nexport const createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\nexport const createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n\n/* c8 ignore stop */\n", "import * as Y from 'yjs'\nimport * as idb from 'lib0/indexeddb'\nimport * as promise from 'lib0/promise'\nimport { Observable } from 'lib0/observable'\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nexport const PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {function(IDBObjectStore):void} [beforeApplyUpdatesCallback]\n * @param {function(IDBObjectStore):void} [afterApplyUpdatesCallback]\n */\nexport const fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {}, afterApplyUpdatesCallback = () => {}) => {\n  const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return idb.getAll(updatesStore, idb.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates => {\n    if (!idbPersistence._destroyed) {\n      beforeApplyUpdatesCallback(updatesStore)\n      Y.transact(idbPersistence.doc, () => {\n        updates.forEach(val => Y.applyUpdate(idbPersistence.doc, val))\n      }, idbPersistence, false)\n      afterApplyUpdatesCallback(updatesStore)\n    }\n  })\n    .then(() => idb.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nexport const storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => idb.del(updatesStore, idb.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => idb.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nexport const clearDocument = name => idb.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nexport class IndexeddbPersistence extends Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._dbref = 0\n    this._dbsize = 0\n    this._destroyed = false\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = idb.openDB(name, db =>\n      idb.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = promise.create(resolve => this.on('synced', () => resolve(this)))\n\n    this._db.then(db => {\n      this.db = db\n      /**\n       * @param {IDBObjectStore} updatesStore\n       */\n      const beforeApplyUpdatesCallback = (updatesStore) => idb.addAutoKey(updatesStore, Y.encodeStateAsUpdate(doc))\n      const afterApplyUpdatesCallback = () => {\n        if (this._destroyed) return this\n        this.synced = true\n        this.emit('synced', [this])\n      }\n      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback)\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._storeUpdate = (update, origin) => {\n      if (this.db && origin !== this) {\n        const [updatesStore] = idb.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n        idb.addAutoKey(updatesStore, update)\n        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n          // debounce store call\n          if (this._storeTimeoutId !== null) {\n            clearTimeout(this._storeTimeoutId)\n          }\n          this._storeTimeoutId = setTimeout(() => {\n            storeState(this, false)\n            this._storeTimeoutId = null\n          }, this._storeTimeout)\n        }\n      }\n    }\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    this._destroyed = true\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      idb.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName], 'readonly')\n      return idb.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = idb.transact(db, [customStoreName])\n      return idb.del(custom, key)\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["create", "transact", "create", "transact", "create"]
}
